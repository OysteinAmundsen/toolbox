{/* editing.mdx */}
import { Meta, Canvas, Controls } from '@storybook/addon-docs/blocks';
import { Tabs, Tab } from '../../../../../../apps/docs/.storybook/components/Tabs';
import * as EditingStories from './editing.stories';

<Meta of={EditingStories} />

# Editing Plugin

The Editing plugin enables inline cell editing in the grid. It provides built-in editors for common data types and supports custom editor functions for specialized input scenarios.

## Why Opt-In?

Editing is delivered as a plugin rather than built into the core grid for several reasons:

- **Smaller bundle size** ‚Äî Applications that only display data don't pay for editing code
- **Clear intent** ‚Äî Explicit plugin registration makes editing capability obvious in code
- **Runtime validation** ‚Äî Using `editable: true` without the plugin throws a helpful error

## Installation

```ts
import { EditingPlugin } from '@toolbox-web/grid/plugins/editing';
```

## Basic Usage

Add the plugin to enable `editable` and `editor` column properties:

<Tabs>
  <Tab label="Vanilla JS">
```ts
import '@toolbox-web/grid';
import { EditingPlugin } from '@toolbox-web/grid/plugins/editing';

const grid = document.querySelector('tbw-grid');
grid.gridConfig = {
  columns: [
    { field: 'id', header: 'ID' },
    { field: 'name', header: 'Name', editable: true },
    { field: 'price', header: 'Price', type: 'number', editable: true },
    { field: 'active', header: 'Active', type: 'boolean', editable: true },
  ],
  plugins: [new EditingPlugin({ editOn: 'dblclick' })], // or 'click'
};

// Listen for commits
grid.addEventListener('cell-commit', (e) => {
  console.log('Cell edited:', e.detail);
});
```
  </Tab>
  <Tab label="React">
```tsx
import { DataGrid, type ReactGridConfig } from '@toolbox-web/grid-react';
import { EditingPlugin } from '@toolbox-web/grid/plugins/editing';

const config: ReactGridConfig = {
  columns: [
    { field: 'id', header: 'ID' },
    { field: 'name', header: 'Name', editable: true },
    { field: 'price', header: 'Price', type: 'number', editable: true },
    { field: 'active', header: 'Active', type: 'boolean', editable: true },
  ],
  plugins: [new EditingPlugin({ editOn: 'dblclick' })],
};

function MyGrid({ data }) {
  return (
    <DataGrid
      rows={data}
      gridConfig={config}
      onCellCommit={(e) => console.log('Edited:', e.detail)}
    />
  );
}
```
  </Tab>
  <Tab label="Angular">
```typescript
import { Component, CUSTOM_ELEMENTS_SCHEMA } from '@angular/core';
import { Grid, TbwEditor } from '@toolbox-web/grid-angular';
import { EditingPlugin } from '@toolbox-web/grid/plugins/editing';
import type { GridConfig } from '@toolbox-web/grid';

@Component({
  imports: [Grid, TbwEditor],
  schemas: [CUSTOM_ELEMENTS_SCHEMA],
  template: `
    <tbw-grid [rows]="data" [gridConfig]="config" (cellCommit)="onCommit($event)" />
  `
})
export class MyGridComponent {
  data = [...];
  config: GridConfig = {
    columns: [
      { field: 'id', header: 'ID' },
      { field: 'name', header: 'Name', editable: true },
      { field: 'price', header: 'Price', type: 'number', editable: true },
    ],
    plugins: [new EditingPlugin({ editOn: 'dblclick' })],
  };

  onCommit(event: CustomEvent) {
    console.log('Edited:', event.detail);
  }
}
```
  </Tab>
</Tabs>

### Try It

Double-click any cell to start editing. Press Enter to commit or Escape to cancel.

<Canvas of={EditingStories.BasicEditing} withToolbar />

## Add/Remove Rows

To dynamically add or remove rows from the grid, simply assign a new array to the `rows` property. The grid reactively updates to display the new data. Use a custom `renderer` in an "Actions" column to provide a delete button for each row.

<Canvas of={EditingStories.AddRemoveRows} withToolbar />

## Programmatic Row Updates

To update individual row values without reassigning the entire `rows` array, use the **Row Update API**:

```typescript
// Update a single row by ID
grid.updateRow('emp-123', { status: 'active', salary: 75000 });

// Batch update multiple rows
grid.updateRows([
  { id: 'emp-123', changes: { status: 'active' } },
  { id: 'emp-456', changes: { department: 'Engineering' } },
]);

// Listen for programmatic updates
grid.addEventListener('cell-change', (e) => {
  console.log('Row updated:', e.detail.rowId, e.detail.changes);
});
```

> **Note:** The `cell-change` event fires for programmatic updates via `updateRow()`/`updateRows()`. The `cell-commit` event fires for inline edits made by users.

See the [API Reference](../?path=/docs/grid-api--docs#row-update-api) for full documentation.

## Edit Triggers

Configure how editing is triggered with the `editOn` option in the EditingPlugin:

```ts
new EditingPlugin({ editOn: 'dblclick' }) // or 'click', 'manual'
```

| Value       | Behavior                                      |
| ----------- | --------------------------------------------- |
| `'click'`   | Single click on cell enters edit mode         |
| `'dblclick'`| Double-click on cell enters edit mode (default) |
| `'manual'`  | Programmatic only via `startEdit(row, field)` |

Additionally, pressing **Enter** or **F2** on a focused cell will start editing.

## Built-in Editors

The grid provides appropriate editors based on column `type`:

| Column Type | Editor                              |
| ----------- | ----------------------------------- |
| `string`    | Text input                          |
| `number`    | Number input with validation        |
| `boolean`   | Checkbox                            |
| `date`      | Date picker input                   |
| `select`    | Dropdown (requires `options` array) |

<Canvas of={EditingStories.AllColumnTypes} withToolbar />

## Editor Parameters

Configure built-in editors using the `editorParams` property. This allows you to set constraints and attributes without creating a custom editor.

### Number Editor

```ts
{
  field: 'price',
  type: 'number',
  editable: true,
  editorParams: {
    min: 0,           // Minimum value
    max: 1000000,     // Maximum value
    step: 0.01,       // Increment for up/down arrows
    placeholder: 'Enter price'
  }
}
```

### Text Editor

```ts
{
  field: 'name',
  editable: true,
  editorParams: {
    maxLength: 100,          // Maximum character length
    pattern: '[A-Za-z\\s]+', // HTML5 validation pattern
    placeholder: 'Enter name'
  }
}
```

### Date Editor

```ts
{
  field: 'startDate',
  type: 'date',
  editable: true,
  editorParams: {
    min: '2024-01-01',  // Minimum date (ISO format)
    max: '2024-12-31',  // Maximum date (ISO format)
    placeholder: 'Select date'
  }
}
```

### Select Editor

```ts
{
  field: 'status',
  type: 'select',
  editable: true,
  options: [
    { label: 'Active', value: 'active' },
    { label: 'Inactive', value: 'inactive' }
  ],
  editorParams: {
    includeEmpty: true,          // Add empty option at start
    emptyLabel: '-- Select --'   // Label for empty option
  }
}
```

### TypeScript Types

```ts
import type {
  EditorParams,
  NumberEditorParams,
  TextEditorParams,
  DateEditorParams,
  SelectEditorParams
} from '@toolbox-web/grid/plugins/editing';
```

## Type-Level Defaults

Instead of configuring renderers and editors on every column, you can define **type-level defaults** that apply to all columns of a given type. This is especially useful for custom types like `country`, `currency`, or `status` that appear across multiple grids.

### Grid-Level Type Defaults

Define type defaults in your grid configuration:

<Tabs>
  <Tab label="Vanilla JS">
```ts
import '@toolbox-web/grid';
import { EditingPlugin } from '@toolbox-web/grid/plugins/editing';

const grid = document.querySelector('tbw-grid');

// Define custom renderers/editors for types
grid.gridConfig = {
  columns: [
    { field: 'name', header: 'Name', editable: true },
    { field: 'country', header: 'Country', type: 'country', editable: true },
    { field: 'priority', header: 'Priority', type: 'priority' },
  ],
  // Type defaults apply to all columns with matching type
  typeDefaults: {
    country: {
      renderer: (ctx) => {
        const span = document.createElement('span');
        span.textContent = `üåç ${ctx.value}`;
        return span;
      },
      editor: (ctx) => {
        const select = document.createElement('select');
        ['USA', 'UK', 'Germany', 'France'].forEach(c => {
          const opt = document.createElement('option');
          opt.value = c;
          opt.textContent = c;
          select.appendChild(opt);
        });
        select.value = ctx.value;
        select.onchange = () => ctx.commit(select.value);
        return select;
      },
    },
    priority: {
      renderer: (ctx) => {
        const div = document.createElement('div');
        div.className = `priority-${ctx.value}`;
        div.textContent = ctx.value;
        return div;
      },
    },
  },
  plugins: [new EditingPlugin()],
};
```
  </Tab>
  <Tab label="React">
```tsx
import { DataGrid, type ReactGridConfig } from '@toolbox-web/grid-react';
import { EditingPlugin } from '@toolbox-web/grid/plugins/editing';

// Type defaults with React components
const config: ReactGridConfig = {
  columns: [
    { field: 'name', header: 'Name', editable: true },
    { field: 'country', header: 'Country', type: 'country', editable: true },
    { field: 'priority', header: 'Priority', type: 'priority' },
  ],
  typeDefaults: {
    country: {
      renderer: (ctx) => <span>üåç {ctx.value}</span>,
      editor: (ctx) => (
        <select
          defaultValue={ctx.value}
          onChange={(e) => ctx.commit(e.target.value)}
        >
          <option value="USA">USA</option>
          <option value="UK">UK</option>
          <option value="Germany">Germany</option>
        </select>
      ),
    },
    priority: {
      renderer: (ctx) => (
        <span className={`priority-${ctx.value}`}>{ctx.value}</span>
      ),
    },
  },
  plugins: [new EditingPlugin()],
};

function MyGrid({ data }) {
  return <DataGrid rows={data} gridConfig={config} />;
}
```
  </Tab>
  <Tab label="Angular">
```typescript
import { Component, CUSTOM_ELEMENTS_SCHEMA } from '@angular/core';
import { Grid } from '@toolbox-web/grid-angular';
import { EditingPlugin } from '@toolbox-web/grid/plugins/editing';
import type { GridConfig } from '@toolbox-web/grid';

@Component({
  imports: [Grid],
  schemas: [CUSTOM_ELEMENTS_SCHEMA],
  template: `<tbw-grid [rows]="data" [gridConfig]="config" />`
})
export class MyGridComponent {
  data = [...];
  config: GridConfig = {
    columns: [
      { field: 'name', header: 'Name', editable: true },
      { field: 'country', header: 'Country', type: 'country', editable: true },
    ],
    typeDefaults: {
      country: {
        renderer: (ctx) => {
          const span = document.createElement('span');
          span.textContent = `üåç ${ctx.value}`;
          return span;
        },
      },
    },
    plugins: [new EditingPlugin()],
  };
}
```
  </Tab>
</Tabs>

### Application-Level Type Defaults

For defaults that apply across **all grids** in your application, use the framework adapter's type registry:

<Tabs>
  <Tab label="React">
```tsx
// app.tsx
import { GridTypeProvider, type TypeDefaultsMap } from '@toolbox-web/grid-react';
import { CountryBadge, CountryEditor } from './components';

// Define app-wide type defaults
const typeDefaults: TypeDefaultsMap = {
  country: {
    renderer: (ctx) => <CountryBadge code={ctx.value} />,
    editor: (ctx) => (
      <CountryEditor value={ctx.value} onCommit={ctx.commit} />
    ),
  },
  currency: {
    renderer: (ctx) => <span>${ctx.value.toFixed(2)}</span>,
  },
};

function App() {
  return (
    <GridTypeProvider defaults={typeDefaults}>
      <Dashboard />
    </GridTypeProvider>
  );
}

// Any grid with type: 'country' columns now uses these components
function Dashboard() {
  return (
    <DataGrid
      rows={employees}
      gridConfig={{
        columns: [
          { field: 'name', header: 'Name' },
          { field: 'country', type: 'country', editable: true }, // Uses CountryBadge/Editor
          { field: 'salary', type: 'currency' }, // Uses currency renderer
        ],
        plugins: [new EditingPlugin()],
      }}
    />
  );
}
```
  </Tab>
  <Tab label="Angular">
```typescript
// app.config.ts
import { ApplicationConfig } from '@angular/core';
import { provideGridTypeDefaults } from '@toolbox-web/grid-angular';
import { CountryBadgeComponent, CountryEditorComponent } from './components';

export const appConfig: ApplicationConfig = {
  providers: [
    provideGridTypeDefaults({
      country: {
        renderer: CountryBadgeComponent,
        editor: CountryEditorComponent,
      },
      currency: {
        renderer: CurrencyCellComponent,
      },
    }),
  ],
};

// grid.component.ts - type defaults automatically apply
@Component({
  template: `<tbw-grid [rows]="data" [gridConfig]="config" />`
})
export class GridComponent {
  config: GridConfig = {
    columns: [
      { field: 'name', header: 'Name' },
      { field: 'country', type: 'country', editable: true }, // Uses registered components
      { field: 'salary', type: 'currency' },
    ],
    plugins: [new EditingPlugin()],
  };
}
```
  </Tab>
</Tabs>

### Resolution Priority

When resolving a renderer or editor, the grid checks in this order:

1. **Column-level** ‚Äî `column.renderer` or `column.editor`
2. **Grid-level** ‚Äî `gridConfig.typeDefaults[column.type]`
3. **App-level** ‚Äî Framework adapter's type registry
4. **Built-in** ‚Äî Default editors for `string`, `number`, `boolean`, etc.

A column-level renderer/editor always takes precedence, allowing overrides when needed.

### Editor Parameters Merging

When using type defaults with `editorParams`, parameters are merged with column-level params taking precedence:

```ts
// Grid config
typeDefaults: {
  number: {
    editorParams: { min: 0, step: 1 }, // Type-level defaults
  },
}

// Column config
{ field: 'price', type: 'number', editorParams: { step: 0.01 } }

// Result: { min: 0, step: 0.01 } ‚Äî column's step overrides type default
```

### Custom Type Names

The `type` property accepts any string, not just built-in types. Use descriptive names for your domain:

```ts
type: 'country'    // Geographic data
type: 'currency'   // Money values
type: 'priority'   // High/Medium/Low
type: 'status'     // Active/Pending/Archived
type: 'rating'     // Star ratings
```

TypeScript provides IntelliSense for built-in types while allowing custom strings:

```ts
import type { ColumnType } from '@toolbox-web/grid';

const type: ColumnType = 'country'; // Works! Custom types allowed
```

## Custom Editors

For specialized input needs, provide a custom `editor` function:

```ts
{
  field: 'status',
  header: 'Status',
  editable: true,
  editor: (ctx) => {
    const select = document.createElement('select');
    select.innerHTML = `
      <option value="pending">Pending</option>
      <option value="active">Active</option>
      <option value="completed">Completed</option>
    `;
    select.value = ctx.value;

    // Commit on change
    select.onchange = () => ctx.commit(select.value);

    // Cancel on Escape
    select.onkeydown = (e) => {
      if (e.key === 'Escape') ctx.cancel();
    };

    return select;
  },
}
```

Double-click the Priority column to see button-based editing:

<Canvas of={EditingStories.CustomEditor} withToolbar />

### Editor Context

The `ctx` object passed to custom editors contains:

| Property | Type | Description |
| -------- | ---- | ----------- |
| `value` | `unknown` | Current cell value |
| `row` | `T` | Full row data |
| `column` | `ColumnConfig` | Column configuration |
| `field` | `string` | Field name |
| `rowIndex` | `number` | Row index in data array |
| `commit(value)` | `function` | Call to save new value |
| `cancel()` | `function` | Call to discard changes |

## Keyboard Navigation

| Key | Action |
| --- | ------ |
| **Enter** / **F2** | Start editing focused cell |
| **Enter** | Commit edit and move down |
| **Tab** | Commit and move to next editable cell |
| **Shift+Tab** | Commit and move to previous editable cell |
| **Escape** | Cancel edit, restore original value |

## Events

| Event | Description |
| ----- | ----------- |
| `cell-commit` | Fired after a cell value is committed |
| `row-commit` | Fired after row-based editing session ends |

### `cell-commit` Detail

```ts
interface CellCommitDetail<T> {
  row: T;           // Row data
  field: string;    // Field name
  value: unknown;   // New value
  oldValue: unknown; // Previous value
  rowIndex: number; // Row index
}
```

## Configuration Validation

If you use `editable: true` or `editor` without registering the `EditingPlugin`, the grid throws a helpful error:

```
[tbw-grid] Configuration error:

Column(s) [name, price] use the "editable" column property, but the required plugin is not loaded.
  ‚Üí Add the plugin to your gridConfig.plugins array:
    import { EditingPlugin } from '@toolbox-web/grid/plugins/editing';
    plugins: [new EditingPlugin(), ...]
```

This runtime validation helps catch misconfigurations early during development.

## Related Plugins

- **[Undo/Redo](../?path=/docs/grid-plugins-undo-redo--docs)** ‚Äî Track edit history with Ctrl+Z/Y
- **[Clipboard](../?path=/docs/grid-plugins-clipboard--docs)** ‚Äî Copy/paste with Ctrl+C/V
