{/* editing.mdx */}
import { Meta, Canvas, Controls } from '@storybook/addon-docs/blocks';
import { Tabs, Tab } from '../../../../../../apps/docs/.storybook/components/Tabs';
import * as EditingStories from './editing.stories';

<Meta of={EditingStories} />

# Editing Plugin

The Editing plugin enables inline cell editing in the grid. It provides built-in editors for common data types and supports custom editor functions for specialized input scenarios.

## Why Opt-In?

Editing is delivered as a plugin rather than built into the core grid for several reasons:

- **Smaller bundle size** ‚Äî Applications that only display data don't pay for editing code
- **Clear intent** ‚Äî Explicit plugin registration makes editing capability obvious in code
- **Runtime validation** ‚Äî Using `editable: true` without the plugin throws a helpful error

## Installation

```ts
import { EditingPlugin } from '@toolbox-web/grid/plugins/editing';
```

## Basic Usage

Add the plugin to enable `editable` and `editor` column properties:

<Tabs>
  <Tab label="Vanilla JS">
```ts
import '@toolbox-web/grid';
import { EditingPlugin } from '@toolbox-web/grid/plugins/editing';

const grid = document.querySelector('tbw-grid');
grid.gridConfig = {
  columns: [
    { field: 'id', header: 'ID' },
    { field: 'name', header: 'Name', editable: true },
    { field: 'price', header: 'Price', type: 'number', editable: true },
    { field: 'active', header: 'Active', type: 'boolean', editable: true },
  ],
  plugins: [new EditingPlugin({ editOn: 'dblclick' })], // or 'click'
};

// Listen for commits
grid.addEventListener('cell-commit', (e) => {
  console.log('Cell edited:', e.detail);
});
```
  </Tab>
  <Tab label="React">
```tsx
import { DataGrid, type ReactGridConfig } from '@toolbox-web/grid-react';
import { EditingPlugin } from '@toolbox-web/grid/plugins/editing';

const config: ReactGridConfig = {
  columns: [
    { field: 'id', header: 'ID' },
    { field: 'name', header: 'Name', editable: true },
    { field: 'price', header: 'Price', type: 'number', editable: true },
    { field: 'active', header: 'Active', type: 'boolean', editable: true },
  ],
  plugins: [new EditingPlugin({ editOn: 'dblclick' })],
};

function MyGrid({ data }) {
  return (
    <DataGrid
      rows={data}
      gridConfig={config}
      onCellCommit={(e) => console.log('Edited:', e.detail)}
    />
  );
}
```
  </Tab>
  <Tab label="Vue">
```html
<script setup>
import '@toolbox-web/grid-vue/features/editing';
import { TbwGrid, TbwGridColumn } from '@toolbox-web/grid-vue';

const data = [
  { id: 1, name: 'Widget', price: 9.99, active: true },
  { id: 2, name: 'Gadget', price: 19.99, active: false },
];

const onCellCommit = (e) => {
  console.log('Cell edited:', e.detail);
};
</script>

<template>
  <TbwGrid :rows="data" editing="dblclick" @cell-commit="onCellCommit" style="height: 400px">
    <TbwGridColumn field="id" header="ID" />
    <TbwGridColumn field="name" header="Name" editable />
    <TbwGridColumn field="price" header="Price" type="number" editable />
    <TbwGridColumn field="active" header="Active" type="boolean" editable />
  </TbwGrid>
</template>
```
  </Tab>
  <Tab label="Angular">
```typescript
// Feature import - enables the [editing] input
import '@toolbox-web/grid-angular/features/editing';

import { Component } from '@angular/core';
import { Grid, TbwEditor } from '@toolbox-web/grid-angular';
import type { ColumnConfig } from '@toolbox-web/grid';

@Component({
  imports: [Grid, TbwEditor],
  template: `
    <tbw-grid
      [rows]="data"
      [columns]="columns"
      [editing]="true"
      (cellCommit)="onCommit($event)" />
  `
})
export class MyGridComponent {
  data = [...];
  columns: ColumnConfig[] = [
    { field: 'id', header: 'ID' },
    { field: 'name', header: 'Name', editable: true },
    { field: 'price', header: 'Price', type: 'number', editable: true },
  ];

  onCommit(event: CustomEvent) {
    console.log('Edited:', event.detail);
  }
}
```
  </Tab>
</Tabs>

### Try It

Double-click any cell to start editing. Press Enter to commit or Escape to cancel.

<Canvas of={EditingStories.BasicEditing} withToolbar />

## Add/Remove Rows

To dynamically add or remove rows from the grid, simply assign a new array to the `rows` property. The grid reactively updates to display the new data. Use a custom `renderer` in an "Actions" column to provide a delete button for each row.

<Canvas of={EditingStories.AddRemoveRows} withToolbar />

## Programmatic Row Updates

To update individual row values without reassigning the entire `rows` array, use the **Row Update API**:

```typescript
// Update a single row by ID
grid.updateRow('emp-123', { status: 'active', salary: 75000 });

// Batch update multiple rows
grid.updateRows([
  { id: 'emp-123', changes: { status: 'active' } },
  { id: 'emp-456', changes: { department: 'Engineering' } },
]);

// Listen for programmatic updates
grid.addEventListener('cell-change', (e) => {
  console.log('Row updated:', e.detail.rowId, e.detail.changes);
});
```

> **Note:** The `cell-change` event fires for programmatic updates via `updateRow()`/`updateRows()`. The `cell-commit` event fires for inline edits made by users.

See the [API Reference](../?path=/docs/grid-api--docs#row-update-api) for full documentation.

## Edit Triggers

Configure how editing is triggered with the `editOn` option in the EditingPlugin:

```ts
new EditingPlugin({ editOn: 'dblclick' }) // or 'click', 'manual'
```

| Value       | Behavior                                      |
| ----------- | --------------------------------------------- |
| `'click'`   | Single click on cell enters edit mode         |
| `'dblclick'`| Double-click on cell enters edit mode (default) |
| `'manual'`  | Programmatic only via `startEdit(row, field)` |

### Keyboard Shortcuts (Row Mode)

| Key | Behavior |
| --- | -------- |
| **Enter** | Start editing the entire row (all editable cells get editors) |
| **F2** | Start editing only the focused cell (single-cell edit) |
| **Escape** | Cancel the current edit and revert changes |
| **Tab** / **Shift+Tab** | Move to next/previous editable cell |
| **Arrow Up/Down** | Commit current edit, exit edit mode, and move to adjacent row |
| **Space** | Toggle boolean cells (when not in edit mode) |

> **Tip:** Use **F2** when you only need to edit one cell without activating editors on the entire row.

## Grid Mode (Spreadsheet-like Editing)

For data entry forms or spreadsheet-like interfaces, use `mode: 'grid'` to make all editable cells show their editors at all times:

```ts
new EditingPlugin({ mode: 'grid' })
```

| Mode    | Behavior                                                    |
| ------- | ----------------------------------------------------------- |
| `'row'` | Default. Click/dblclick to enter edit mode, Escape to exit |
| `'grid'`| All editors visible immediately. Excel-like navigation.     |

In **grid mode**:
- All `editable: true` cells render with their editors on load
- Tab/Shift+Tab navigates between editable cells (wraps to next/prev row)
- `cell-commit` events fire normally when values change

### Excel-like Navigation vs Edit Mode

Grid mode supports Excel-style keyboard interaction with two modes:

| State | How to Enter | Behavior |
| ----- | ------------ | -------- |
| **Navigation** | Press Escape | Arrow keys move between cells. Input is blurred. |
| **Edit** | Press Enter, click input, or start typing | Arrow keys work within the input (cursor position, up/down for numbers). |

- **Escape**: Blurs the current input, switching to navigation mode where arrow keys move the cell focus
- **Enter**: Focuses the current cell's input, switching to edit mode
- **Click**: Clicking directly on an input naturally focuses it (edit mode)
- **Arrow Keys**: In navigation mode, use arrow keys to move between cells. In edit mode, arrows work within the input (e.g., moving cursor in text, incrementing numbers)

This mimics Excel/Google Sheets behavior where you can quickly navigate a grid with arrows, then press Enter to edit a cell.

<Canvas of={EditingStories.GridMode} withToolbar />

## Built-in Editors

The grid provides appropriate editors based on column `type`:

| Column Type | Editor                              |
| ----------- | ----------------------------------- |
| `string`    | Text input                          |
| `number`    | Number input with validation        |
| `boolean`   | Checkbox                            |
| `date`      | Date picker input                   |
| `select`    | Dropdown (requires `options` array) |

<Canvas of={EditingStories.AllColumnTypes} withToolbar />

## Editor Parameters

Configure built-in editors using the `editorParams` property. This allows you to set constraints and attributes without creating a custom editor.

### Number Editor

```ts
{
  field: 'price',
  type: 'number',
  editable: true,
  editorParams: {
    min: 0,           // Minimum value
    max: 1000000,     // Maximum value
    step: 0.01,       // Increment for up/down arrows
    placeholder: 'Enter price'
  }
}
```

### Text Editor

```ts
{
  field: 'name',
  editable: true,
  editorParams: {
    maxLength: 100,          // Maximum character length
    pattern: '[A-Za-z\\s]+', // HTML5 validation pattern
    placeholder: 'Enter name'
  }
}
```

### Date Editor

```ts
{
  field: 'startDate',
  type: 'date',
  editable: true,
  editorParams: {
    min: '2024-01-01',  // Minimum date (ISO format)
    max: '2024-12-31',  // Maximum date (ISO format)
    placeholder: 'Select date'
  }
}
```

### Select Editor

```ts
{
  field: 'status',
  type: 'select',
  editable: true,
  options: [
    { label: 'Active', value: 'active' },
    { label: 'Inactive', value: 'inactive' }
  ],
  editorParams: {
    includeEmpty: true,          // Add empty option at start
    emptyLabel: '-- Select --'   // Label for empty option
  }
}
```

### TypeScript Types

```ts
import type {
  EditorParams,
  NumberEditorParams,
  TextEditorParams,
  DateEditorParams,
  SelectEditorParams
} from '@toolbox-web/grid/plugins/editing';
```

## Type-Level Defaults

Instead of configuring renderers and editors on every column, you can define **type-level defaults** that apply to all columns of a given type. This is especially useful for custom types like `country`, `currency`, or `status` that appear across multiple grids.

### Grid-Level Type Defaults

Define type defaults in your grid configuration:

<Tabs>
  <Tab label="Vanilla JS">
```ts
import '@toolbox-web/grid';
import { EditingPlugin } from '@toolbox-web/grid/plugins/editing';

const grid = document.querySelector('tbw-grid');

// Define custom renderers/editors for types
grid.gridConfig = {
  columns: [
    { field: 'name', header: 'Name', editable: true },
    { field: 'country', header: 'Country', type: 'country', editable: true },
    { field: 'priority', header: 'Priority', type: 'priority' },
  ],
  // Type defaults apply to all columns with matching type
  typeDefaults: {
    country: {
      renderer: (ctx) => {
        const span = document.createElement('span');
        span.textContent = `üåç ${ctx.value}`;
        return span;
      },
      editor: (ctx) => {
        const select = document.createElement('select');
        ['USA', 'UK', 'Germany', 'France'].forEach(c => {
          const opt = document.createElement('option');
          opt.value = c;
          opt.textContent = c;
          select.appendChild(opt);
        });
        select.value = ctx.value;
        select.onchange = () => ctx.commit(select.value);
        return select;
      },
    },
    priority: {
      renderer: (ctx) => {
        const div = document.createElement('div');
        div.className = `priority-${ctx.value}`;
        div.textContent = ctx.value;
        return div;
      },
    },
  },
  plugins: [new EditingPlugin()],
};
```
  </Tab>
  <Tab label="React">
```tsx
import { DataGrid, type ReactGridConfig } from '@toolbox-web/grid-react';
import { EditingPlugin } from '@toolbox-web/grid/plugins/editing';

// Type defaults with React components
const config: ReactGridConfig = {
  columns: [
    { field: 'name', header: 'Name', editable: true },
    { field: 'country', header: 'Country', type: 'country', editable: true },
    { field: 'priority', header: 'Priority', type: 'priority' },
  ],
  typeDefaults: {
    country: {
      renderer: (ctx) => <span>üåç {ctx.value}</span>,
      editor: (ctx) => (
        <select
          defaultValue={ctx.value}
          onChange={(e) => ctx.commit(e.target.value)}
        >
          <option value="USA">USA</option>
          <option value="UK">UK</option>
          <option value="Germany">Germany</option>
        </select>
      ),
    },
    priority: {
      renderer: (ctx) => (
        <span className={`priority-${ctx.value}`}>{ctx.value}</span>
      ),
    },
  },
  plugins: [new EditingPlugin()],
};

function MyGrid({ data }) {
  return <DataGrid rows={data} gridConfig={config} />;
}
```
  </Tab>
  <Tab label="Angular">
```typescript
// Feature import - enables the [editing] input
import '@toolbox-web/grid-angular/features/editing';

import { Component } from '@angular/core';
import { Grid } from '@toolbox-web/grid-angular';
import type { ColumnConfig, TypeDefaultsMap } from '@toolbox-web/grid';

@Component({
  imports: [Grid],
  template: `<tbw-grid [rows]="data" [columns]="columns" [editing]="true" [typeDefaults]="typeDefaults" />`
})
export class MyGridComponent {
  data = [...];
  columns: ColumnConfig[] = [
    { field: 'name', header: 'Name', editable: true },
    { field: 'country', header: 'Country', type: 'country', editable: true },
  ];

  typeDefaults: TypeDefaultsMap = {
    country: {
      renderer: (ctx) => {
        const span = document.createElement('span');
        span.textContent = `üåç ${ctx.value}`;
        return span;
      },
    },
  };
}
```
  </Tab>
</Tabs>

### Application-Level Type Defaults

For defaults that apply across **all grids** in your application, use the framework adapter's type registry:

<Tabs>
  <Tab label="React">
```tsx
// app.tsx
import { GridTypeProvider, type TypeDefaultsMap } from '@toolbox-web/grid-react';
import { CountryBadge, CountryEditor } from './components';

// Define app-wide type defaults
const typeDefaults: TypeDefaultsMap = {
  country: {
    renderer: (ctx) => <CountryBadge code={ctx.value} />,
    editor: (ctx) => (
      <CountryEditor value={ctx.value} onCommit={ctx.commit} />
    ),
  },
  currency: {
    renderer: (ctx) => <span>${ctx.value.toFixed(2)}</span>,
  },
};

function App() {
  return (
    <GridTypeProvider defaults={typeDefaults}>
      <Dashboard />
    </GridTypeProvider>
  );
}

// Any grid with type: 'country' columns now uses these components
function Dashboard() {
  return (
    <DataGrid
      rows={employees}
      gridConfig={{
        columns: [
          { field: 'name', header: 'Name' },
          { field: 'country', type: 'country', editable: true }, // Uses CountryBadge/Editor
          { field: 'salary', type: 'currency' }, // Uses currency renderer
        ],
        plugins: [new EditingPlugin()],
      }}
    />
  );
}
```
  </Tab>
  <Tab label="Angular">
```typescript
// app.config.ts
import { ApplicationConfig } from '@angular/core';
import { provideGridTypeDefaults } from '@toolbox-web/grid-angular';
import { CountryBadgeComponent, CountryEditorComponent } from './components';

export const appConfig: ApplicationConfig = {
  providers: [
    provideGridTypeDefaults({
      country: {
        renderer: CountryBadgeComponent,
        editor: CountryEditorComponent,
      },
      currency: {
        renderer: CurrencyCellComponent,
      },
    }),
  ],
};

// grid.component.ts - type defaults automatically apply
// Feature import - enables the [editing] input
import '@toolbox-web/grid-angular/features/editing';

import { Component } from '@angular/core';
import { Grid } from '@toolbox-web/grid-angular';
import type { ColumnConfig } from '@toolbox-web/grid';

@Component({
  imports: [Grid],
  template: `<tbw-grid [rows]="data" [columns]="columns" [editing]="true" />`
})
export class GridComponent {
  data = [...];
  columns: ColumnConfig[] = [
    { field: 'name', header: 'Name' },
    { field: 'country', type: 'country', editable: true }, // Uses registered components
    { field: 'salary', type: 'currency' },
  ];
}
```
  </Tab>
</Tabs>

### Resolution Priority

When resolving a renderer or editor, the grid checks in this order:

1. **Column-level** ‚Äî `column.renderer` or `column.editor`
2. **Grid-level** ‚Äî `gridConfig.typeDefaults[column.type]`
3. **App-level** ‚Äî Framework adapter's type registry
4. **Built-in** ‚Äî Default editors for `string`, `number`, `boolean`, etc.

A column-level renderer/editor always takes precedence, allowing overrides when needed.

### Editor Parameters Merging

When using type defaults with `editorParams`, parameters are merged with column-level params taking precedence:

```ts
// Grid config
typeDefaults: {
  number: {
    editorParams: { min: 0, step: 1 }, // Type-level defaults
  },
}

// Column config
{ field: 'price', type: 'number', editorParams: { step: 0.01 } }

// Result: { min: 0, step: 0.01 } ‚Äî column's step overrides type default
```

### Custom Type Names

The `type` property accepts any string, not just built-in types. Use descriptive names for your domain:

```ts
type: 'country'    // Geographic data
type: 'currency'   // Money values
type: 'priority'   // High/Medium/Low
type: 'status'     // Active/Pending/Archived
type: 'rating'     // Star ratings
```

TypeScript provides IntelliSense for built-in types while allowing custom strings:

```ts
import type { ColumnType } from '@toolbox-web/grid';

const type: ColumnType = 'country'; // Works! Custom types allowed
```

## Custom Editors

For specialized input needs, provide a custom `editor` function:

```ts
{
  field: 'status',
  header: 'Status',
  editable: true,
  editor: (ctx) => {
    const select = document.createElement('select');
    select.innerHTML = `
      <option value="pending">Pending</option>
      <option value="active">Active</option>
      <option value="completed">Completed</option>
    `;
    select.value = ctx.value;

    // Commit on change
    select.onchange = () => ctx.commit(select.value);

    // Cancel on Escape
    select.onkeydown = (e) => {
      if (e.key === 'Escape') ctx.cancel();
    };

    return select;
  },
}
```

Double-click the Priority column to see button-based editing:

<Canvas of={EditingStories.CustomEditor} withToolbar />

### Editor Context

The `ctx` object passed to custom editors contains:

| Property | Type | Description |
| -------- | ---- | ----------- |
| `value` | `unknown` | Current cell value |
| `row` | `T` | Full row data |
| `column` | `ColumnConfig` | Column configuration |
| `field` | `string` | Field name |
| `rowId` | `string` | Row ID (from `getRowId`) |
| `commit(value)` | `function` | Call to save new value |
| `cancel()` | `function` | Call to discard changes |
| `updateRow(changes)` | `function` | Update other fields on the same row (triggers `cell-change` events) |
| `onValueChange(cb)` | `function` | Register a callback to receive pushed values when the cell's value changes externally (e.g., via `updateRow` from another cell's commit) |

### Cascade Updates (onValueChange)

When one cell's commit updates other fields via `updateRow()`, any editors open on those fields
receive the new value automatically. The grid does this for built-in editors out of the box.

For custom editors, use `onValueChange` to keep your inputs in sync:

```ts
{
  field: 'total',
  editable: true,
  editor: (ctx) => {
    const input = document.createElement('input');
    input.type = 'number';
    input.value = String(ctx.value);

    // Stay in sync when another cell updates this field
    ctx.onValueChange?.((newValue) => {
      input.value = String(newValue ?? '');
    });

    input.onchange = () => ctx.commit(Number(input.value));
    return input;
  },
}
```

This is especially useful when fields are interdependent ‚Äî for example, updating `quantity`
recalculates `total`:

```ts
grid.addEventListener('cell-commit', (e) => {
  if (e.detail.field === 'quantity') {
    const price = e.detail.row.price;
    e.detail.updateRow({ total: price * e.detail.value });
  }
});
```

## Keyboard Shortcuts

| Key | Action |
| --- | ------ |
| **Enter** | Start editing focused cell |
| **Enter** | Commit edit and move down |
| **Tab** | Commit and move to next editable cell |
| **Shift+Tab** | Commit and move to previous editable cell |
| **Escape** | Cancel edit, restore original value |

## Events

The EditingPlugin emits events during the editing lifecycle. Double-click a cell to edit,
then press Enter or click away to see the events:

<Canvas of={EditingStories.EditingEvents} withToolbar />

| Event | Type | Description |
| ----- | ---- | ----------- |
| `edit-open` | `EditOpenDetail` | Fired when a row enters edit mode (row mode only) |
| `before-edit-close` | [`BeforeEditCloseDetail`](/docs/grid-plugins-editing-interfaces-beforeeditclosedetail--docs) | Fires synchronously before edit state is cleared on commit (row mode only). Managed editors (e.g. Angular Material overlay, MUI Popover) can flush pending values. Does **not** fire on revert. |
| `edit-close` | `EditCloseDetail` | Fired when a row exits edit mode ‚Äî commit or cancel (row mode only) |
| `cell-commit` | [`CellCommitDetail`](/docs/grid-plugins-editing-interfaces-cellcommitdetail--docs) | Fired when a cell value is committed (cancelable) |
| `row-commit` | [`RowCommitDetail`](/docs/grid-plugins-editing-interfaces-rowcommitdetail--docs) | Fired when a row editing session ends (cancelable) |
| `changed-rows-reset` | [`ChangedRowsResetDetail`](/docs/grid-plugins-editing-interfaces-changedrowsresetdetail--docs) | Fired when `resetChangedRows()` is called |

## Cell Validation

Use `setInvalid()` in the `cell-commit` event to mark cells as invalid without canceling the edit.
Invalid cells are highlighted with a red outline and can be styled with CSS custom properties.

Use `preventDefault()` in the `row-commit` event to reject the entire row if validation fails,
reverting all changes to the original values.

<Canvas of={EditingStories.CellValidation} withToolbar />

### Validation Methods

The EditingPlugin provides these methods for managing validation state:

| Method | Description |
| ------ | ----------- |
| `setInvalid(rowId, field, message?)` | Mark a cell as invalid |
| `clearInvalid(rowId, field)` | Clear invalid state for a cell |
| `clearRowInvalid(rowId)` | Clear all invalid cells in a row |
| `clearAllInvalid()` | Clear all invalid cells |
| `isCellInvalid(rowId, field)` | Check if a cell is invalid |
| `hasInvalidCells(rowId)` | Check if a row has any invalid cells |
| `getInvalidMessage(rowId, field)` | Get the validation message |

### CSS Custom Properties

Style invalid cells by overriding these CSS variables:

```css
tbw-grid {
  --tbw-invalid-bg: #fef2f2;
  --tbw-invalid-border-color: #ef4444;
}
```

## Configuration Validation

If you use `editable: true` or `editor` without registering the `EditingPlugin`, the grid throws a helpful error:

```
[tbw-grid] Configuration error:

Column(s) [name, price] use the "editable" column property, but the required plugin is not loaded.
  ‚Üí Add the plugin to your gridConfig.plugins array:
    import { EditingPlugin } from '@toolbox-web/grid/plugins/editing';
    plugins: [new EditingPlugin(), ...]
```

This runtime validation helps catch misconfigurations early during development.

## Focus Management

### Focus Trap

Enable `focusTrap` to prevent accidental focus loss during editing. When focus leaves
the grid during an active edit, it is automatically returned to the editing cell:

```ts
new EditingPlugin({
  editOn: 'dblclick',
  focusTrap: true,
})
```

Elements registered via `grid.registerExternalFocusContainer()` are excluded from the
trap ‚Äî overlays (datepickers, dropdowns) continue to work normally.

### External Focus Containers

Custom editors that append elements to `<body>` (e.g., datepicker overlays, dropdown
panels) should register with the grid so focus inside them doesn't close the editor:

```ts
// In your editor function
editor: (ctx) => {
  const input = document.createElement('input');
  const overlay = document.createElement('div');
  overlay.className = 'my-overlay';
  document.body.appendChild(overlay);

  // Register so grid treats the overlay as "inside"
  ctx.grid.registerExternalFocusContainer(overlay);

  // When done, unregister
  ctx.cancel = () => {
    ctx.grid.unregisterExternalFocusContainer(overlay);
    overlay.remove();
  };

  return input;
}
```

> **Angular:** `BaseOverlayEditor` handles registration automatically.

## See Also

- **[Undo/Redo](../?path=/docs/grid-plugins-undo-redo--docs)** ‚Äî Track edit history with Ctrl+Z/Y
- **[Clipboard](../?path=/docs/grid-plugins-clipboard--docs)** ‚Äî Copy/paste with Ctrl+C/V
- **[Selection](../?path=/docs/grid-plugins-selection--docs)** ‚Äî Cell and row selection
