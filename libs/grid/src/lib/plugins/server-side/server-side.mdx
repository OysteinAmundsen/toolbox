import { Meta, Canvas, Controls } from '@storybook/addon-docs/blocks';
import { Tabs, Tab } from '../../../../../../apps/docs/.storybook/components/Tabs';
import * as ServerSideStories from './server-side.stories';

<Meta of={ServerSideStories} />

# Server-Side Plugin

The Server-Side plugin enables **virtual scrolling with lazy loading** from a remote API. It's designed for large datasets (10,000+ rows) where loading all data upfront would be impractical or slow.

## When to Use This Plugin

| Scenario | Recommended Approach |
|----------|---------------------|
| < 1,000 rows | Load all data upfront (no plugin needed) |
| 1,000 - 10,000 rows | Consider based on network speed and data complexity |
| 10,000+ rows | **Use ServerSidePlugin** |
| Infinite scroll / pagination | **Use ServerSidePlugin** |
| Data changes frequently on server | **Use ServerSidePlugin** with `refresh()` |

## Key Features

- **Block-based fetching**: Loads only visible rows plus a buffer
- **LRU caching**: Keeps recently viewed blocks in memory
- **Automatic prefetching**: Loads next blocks as user scrolls
- **Concurrent request limiting**: Prevents overwhelming the server
- **Loading placeholders**: Shows loading state for pending rows
- **Integration with sorting/filtering**: Works with `sortHandler` and `filterHandler`

## Installation

```ts
import { ServerSidePlugin } from '@toolbox-web/grid/plugins/server-side';
```

## Basic Usage

The plugin requires a **data source** that implements the `getRows` method. This is typically set after the grid is ready:

<Tabs>
  <Tab label="Vanilla JS">
```ts
import '@toolbox-web/grid';
import { ServerSidePlugin } from '@toolbox-web/grid/plugins/server-side';

const dataSource = {
  async getRows(params) {
    // params: { startRow, endRow, sortModel, filterModel }
    const response = await fetch(`/api/data?start=${params.startRow}&end=${params.endRow}`);
    const data = await response.json();
    return {
      rows: data.rows,
      totalRowCount: data.total, // Required for scroll height calculation
    };
  },
};

const plugin = new ServerSidePlugin({ pageSize: 50 });

const grid = document.querySelector('tbw-grid');
grid.gridConfig = {
  columns: [
    { field: 'id', header: 'ID' },
    { field: 'name', header: 'Name' },
    { field: 'email', header: 'Email' },
  ],
  plugins: [plugin],
};

// Set data source after grid is ready
grid.ready().then(() => plugin.setDataSource(dataSource));
```
  </Tab>
  <Tab label="React">
```tsx
import '@toolbox-web/grid-react/features/server-side';
import { DataGrid, useGrid } from '@toolbox-web/grid-react';
import { ServerSidePlugin } from '@toolbox-web/grid/plugins/server-side';
import { useEffect, useMemo } from 'react';

const dataSource = {
  async getRows(params) {
    const response = await fetch(`/api/data?start=${params.startRow}&end=${params.endRow}`);
    const data = await response.json();
    return { rows: data.rows, totalRowCount: data.total };
  },
};

function ServerSideGrid() {
  const { ref, element } = useGrid();

  useEffect(() => {
    if (element) {
      element.ready().then(() => {
        const plugin = element.getPlugin(ServerSidePlugin);
        plugin?.setDataSource(dataSource);
      });
    }
  }, [element]);

  return (
    <DataGrid
      ref={ref}
      columns={[
        { field: 'id', header: 'ID' },
        { field: 'name', header: 'Name' },
        { field: 'email', header: 'Email' },
      ]}
      serverSide={{ pageSize: 50 }}
      style={{ height: '400px' }}
    />
  );
}
```
  </Tab>
  <Tab label="Vue">
```html
<script setup>
import { TbwGrid, TbwGridColumn } from '@toolbox-web/grid-vue';
import { ServerSidePlugin } from '@toolbox-web/grid/plugins/server-side';
import { ref, markRaw, onMounted } from 'vue';

const gridRef = ref(null);

const dataSource = {
  async getRows(params) {
    const response = await fetch(`/api/data?start=${params.startRow}&end=${params.endRow}`);
    const data = await response.json();
    return { rows: data.rows, totalRowCount: data.total };
  },
};

const serverSidePlugin = markRaw(new ServerSidePlugin({ pageSize: 50 }));

onMounted(async () => {
  await gridRef.value?.element?.ready();
  serverSidePlugin.setDataSource(dataSource);
});
</script>

<template>
  <TbwGrid ref="gridRef" :plugins="[serverSidePlugin]" style="height: 400px">
    <TbwGridColumn field="id" header="ID" />
    <TbwGridColumn field="name" header="Name" />
    <TbwGridColumn field="email" header="Email" />
  </TbwGrid>
</template>
```
  </Tab>
  <Tab label="Angular">
```typescript
// Feature import - enables the [serverSide] input
import '@toolbox-web/grid-angular/features/server-side';

import { Component, viewChild, ElementRef } from '@angular/core';
import { Grid } from '@toolbox-web/grid-angular';
import { ServerSidePlugin } from '@toolbox-web/grid/plugins/server-side';
import type { ColumnConfig, GridElement } from '@toolbox-web/grid';

@Component({
  selector: 'app-server-side-grid',
  imports: [Grid],
  template: `
    <tbw-grid
      #grid
      [columns]="columns"
      [serverSide]="{ pageSize: 50 }"
      style="height: 400px; display: block;">
    </tbw-grid>
  `,
})
export class ServerSideGridComponent {
  gridRef = viewChild<ElementRef<GridElement>>('grid');

  columns: ColumnConfig[] = [
    { field: 'id', header: 'ID' },
    { field: 'name', header: 'Name' },
    { field: 'email', header: 'Email' },
  ];

  private dataSource = {
    getRows: async (params: any) => {
      const response = await fetch(`/api/data?start=${params.startRow}&end=${params.endRow}`);
      const data = await response.json();
      return { rows: data.rows, totalRowCount: data.total };
    },
  };

  ngAfterViewInit() {
    this.gridRef()?.nativeElement.ready().then(() => {
      const plugin = this.gridRef()?.nativeElement.getPlugin(ServerSidePlugin);
      plugin?.setDataSource(this.dataSource);
    });
  }
}
```
  </Tab>
</Tabs>

## Demos

### Virtual Scroll Mode

<Canvas of={ServerSideStories.Default} withToolbar />
<Controls of={ServerSideStories.Default} />

### Paging Mode

<Canvas of={ServerSideStories.PagingMode} withToolbar />

### Server-Side Sorting

Use the `sortHandler` config option for async sorting. When a user clicks a sortable column header,
your handler is called instead of the built-in sorting logic. This is ideal for large datasets
where sorting should happen on the backend.

<Canvas of={ServerSideStories.ServerSideSorting} withToolbar />

```ts
grid.gridConfig = {
  columns: [...],
  sortHandler: async (rows, sortState, columns) => {
    // sortState: { field: 'name', direction: 1 } // 1 = asc, -1 = desc
    const response = await fetch(
      `/api/data?sort=${sortState.field}&dir=${sortState.direction === 1 ? 'asc' : 'desc'}`
    );
    return response.json();
  },
};
```

The handler receives:

- `rows` - Current row array (may be useful for optimistic updates)
- `sortState` - `{ field: string, direction: 1 | -1 }`
- `columns` - Column configurations (access `sortComparator` if needed)

Return the sorted array directly or a Promise that resolves to it.

### Server-Side Filtering

For server-side filtering, use the FilteringPlugin's async handlers.
See the [Filtering Plugin documentation](?path=/docs/grid-plugins-filtering--docs#async-handlers-for-server-side-filtering) for details on `valuesHandler` and `filterHandler`.

## Configuration Options

| Option                  | Type     | Default    | Description                |
| ----------------------- | -------- | ---------- | -------------------------- |
| `pageSize`              | `number` | `100`      | Rows per block             |
| `cacheBlockSize`        | `number` | `pageSize` | Cache block size           |
| `maxConcurrentRequests` | `number` | `2`        | Max parallel data requests |

## TypeScript Interfaces

```ts
interface ServerSideDataSource {
  getRows(params: GetRowsParams): Promise<GetRowsResult>;
}

interface GetRowsParams {
  startRow: number;
  endRow: number;
  sortModel?: { field: string; direction: 'asc' | 'desc' }[];
  filterModel?: Record<string, FilterCondition>;
}

interface GetRowsResult {
  rows: any[];
  totalRowCount: number;
}
```

## Programmatic API

```ts
const plugin = grid.getPlugin(ServerSidePlugin);

plugin.setDataSource(newDataSource);  // Set or replace the data source
plugin.refresh();                      // Reload current viewport from server
plugin.purgeCache();                   // Clear all cached blocks
plugin.getTotalRowCount();             // Get server-reported total row count
plugin.isRowLoaded(index);             // Check if a specific row is in cache
plugin.getLoadedBlockCount();          // Number of blocks currently cached
```

## Architecture: How It Works

The plugin uses a **block-based caching strategy**:

```
┌────────────────────────────────────────────────┐
│  Total Dataset: 100,000 rows (on server)       │
├────────────────────────────────────────────────┤
│  Block 0: rows 0-99     [CACHED]               │
│  Block 1: rows 100-199  [CACHED]               │
│  Block 2: rows 200-299  [LOADING...]           │
│  Block 3: rows 300-399  [NOT LOADED]           │
│  ...                                           │
│  Block 999: rows 99900-99999 [NOT LOADED]      │
└────────────────────────────────────────────────┘
```

**Scroll triggers:**
1. `onScroll` event fires
2. Plugin calculates which blocks are needed for the visible viewport
3. Missing blocks are requested from the data source
4. `requestRender()` is called when data arrives
5. Grid re-renders with new data

**Loading state:**
Rows that haven't loaded yet are represented with placeholder objects:
```ts
{ __loading: true, __index: 42 }
```

You can style loading rows with CSS:
```css
.data-grid-row:has([data-loading]) {
  opacity: 0.5;
}
```

## Combining with Other Plugins

The ServerSidePlugin works well with:

| Plugin | Integration |
|--------|-------------|
| `FilteringPlugin` | Use `filterHandler` for server-side filtering |
| `MultiSortPlugin` | Use `sortHandler` for server-side sorting |
| `SelectionPlugin` | Works normally - selection state is client-side |
| `EditingPlugin` | Works normally - edits are local until you sync |
| `ExportPlugin` | Only exports cached rows by default |

**Note:** `RowGroupingPlugin` and `TreePlugin` are not recommended with server-side data as they require all data to be present for grouping calculations.

## See Also

- **[Filtering](../?path=/docs/grid-plugins-filtering--docs)** — Client-side filtering
- **[Multi-Sort](../?path=/docs/grid-plugins-multi-sort--docs)** — Client-side multi-sort
- **[Export](../?path=/docs/grid-plugins-export--docs)** — Export grid data
