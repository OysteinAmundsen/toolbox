{/* @jsxRuntime automatic */}

import { Meta, Source } from '@storybook/addon-docs/blocks';

<Meta title="Grid/Angular/Reactive Forms Integration" />

# Reactive Forms Integration

The `@toolbox-web/grid-angular` package provides seamless integration with Angular Reactive Forms, allowing the grid to act as a form-bound component with cell-level validation.

## Overview

You can bind a grid to a `FormArray` using the `[formArray]` directive. This enables:

- **Two-way data binding** - FormArray value changes update the grid, and cell edits update the FormArray
- **Validation state** - Access cell-level and row-level validation
- **Dirty/touched tracking** - Know when users have interacted with the grid
- **FormControl in editors** - Custom editors can bind directly to cell-level FormControls

## Usage with FormArray

Use a `FormArray` of `FormGroup`s for full validation support. This exposes cell-level `FormControl`s in the editor context:

<Source
  language="typescript"
  code={`
import { Component, CUSTOM_ELEMENTS_SCHEMA, inject, input, output } from '@angular/core';
import {
  FormArray, FormBuilder, FormControl, FormGroup,
  ReactiveFormsModule, Validators, AbstractControl
} from '@angular/forms';
import { Grid, GridFormArray, TbwEditor, TbwRenderer } from '@toolbox-web/grid-angular';
import { EditingPlugin } from '@toolbox-web/grid/plugins/editing';

// Custom validated input editor
@Component({
  selector: 'app-validated-input',
  standalone: true,
  imports: [ReactiveFormsModule],
  template: \`
    @if (control()) {
      <input
        [formControl]="control()"
        [class.is-invalid]="control()!.invalid && control()!.touched"
      />
      @if (control()!.invalid && control()!.touched) {
        <small class="error">{{ getErrorMessage() }}</small>
      }
    }
  \`,
  styles: \`
    .is-invalid { border-color: red; }
    .error { color: red; font-size: 0.8em; }
  \`
})
export class ValidatedInputComponent {
  control = input<AbstractControl>();
  commit = output<string>();

  getErrorMessage(): string {
    const ctrl = this.control();
    if (ctrl?.hasError('required')) return 'Required';
    if (ctrl?.hasError('min')) return 'Value too low';
    return 'Invalid';
  }
}

@Component({
  imports: [
    Grid, GridFormArray, TbwRenderer, TbwEditor,
    ReactiveFormsModule, ValidatedInputComponent
  ],
  schemas: [CUSTOM_ELEMENTS_SCHEMA],
  template: \`
    <form [formGroup]="form">
      <tbw-grid [formArray]="form.controls.employees" [gridConfig]="config" style="height: 400px; display: block;">
        <tbw-grid-column field="age" editable>
          <span *tbwRenderer="let value">{{ value }}</span>
          <!-- The 'control' gives you the FormControl for this cell -->
          <app-validated-input *tbwEditor="let value; control as ctrl" [control]="ctrl" />
        </tbw-grid-column>
      </tbw-grid>
    </form>

    <div class="validation-summary">
      <p>Form Valid: {{ form.valid }}</p>
      <p>Dirty: {{ form.controls.employees.dirty }}</p>
      <p>Touched: {{ form.controls.employees.touched }}</p>
      <p>Errors: {{ getFormErrors() | json }}</p>
    </div>
  \`
})
export class FormArrayExample {
  private fb = inject(FormBuilder);

  form = this.fb.group({
    employees: this.fb.array([
      this.fb.group({
        name: ['Alice', Validators.required],
        age: [30, [Validators.required, Validators.min(18)]],
      }),
      this.fb.group({
        name: ['Bob', Validators.required],
        age: [25, [Validators.required, Validators.min(18)]],
      }),
    ])
  });

  config = {
    columns: [
      { field: 'name', header: 'Name', editable: true },
      { field: 'age', header: 'Age', editable: true },
    ],
    plugins: [new EditingPlugin()],
  };

  getFormErrors(): string[] {
    const errors: string[] = [];
    this.form.controls.employees.controls.forEach((group, idx) => {
      Object.keys(group.controls).forEach(field => {
        const ctrl = group.get(field);
        if (ctrl?.errors) {
          errors.push(\`Row \${idx}, \${field}: \${JSON.stringify(ctrl.errors)}\`);
        }
      });
    });
    return errors;
  }
}
`}
/>

## Row-Level Validation

When using `FormArray` with `FormGroup`s, you can access row-level validation state:

<Source
  language="typescript"
  code={`
import { getFormArrayContext } from '@toolbox-web/grid-angular';

// Get validation context from grid element
const context = getFormArrayContext(gridElement);

if (context?.hasFormGroups) {
  // Check row validation state
  const isRowValid = context.isRowValid(0);      // All controls valid?
  const isRowTouched = context.isRowTouched(0);  // Any control touched?
  const isRowDirty = context.isRowDirty(0);      // Any control changed?

  // Get aggregated errors for a row
  const errors = context.getRowErrors(0);
  // Returns: { name: { required: true }, age: { min: { min: 18, actual: 15 } } }

  // Get the FormGroup for advanced use
  const formGroup = context.getRowFormGroup(0);
}
`}
/>

## Editor Context Properties

When using `*tbwEditor`, the following context is available:

| Property   | Type              | Description |
|------------|-------------------|-------------|
| `value`    | `TValue`          | Current cell value |
| `row`      | `TRow`            | Full row data object |
| `column`   | `ColumnConfig`    | Column configuration |
| `onCommit` | `Function`        | Commit callback |
| `onCancel` | `Function`        | Cancel callback |
| `control`  | `AbstractControl` | Cell's FormControl (FormArray+FormGroup only) |

## Automatic Validation Syncing

When using `GridFormArray`, Angular's FormControl validation is **automatically synced** to the grid's visual invalid styling. This means:

1. **After a cell is edited**, if the FormControl is invalid, the cell shows a red border/background
2. **When the FormControl becomes valid**, the invalid styling is automatically cleared
3. **On row-commit**, if the FormGroup has invalid controls, the commit is **prevented** and the row reverts to its original values

This happens by default with `syncValidation="true"` (the default). You can disable it:

<Source
  language="html"
  code={`
<!-- Disable automatic validation sync if you want manual control -->
<tbw-grid [formArray]="rows" [syncValidation]="false" ... />
`}
/>

### How It Works

The `GridFormArray` directive listens to `cell-commit` events and checks the corresponding FormControl's validity. If invalid, it calls `EditingPlugin.setInvalid()` with a human-readable error message derived from Angular's validation errors.

Supported Angular validators are automatically translated to error messages:

| Validator | Generated Message |
|-----------|-------------------|
| `required` | "This field is required" |
| `minlength` | "Minimum length is X" |
| `maxlength` | "Maximum length is X" |
| `min` | "Minimum value is X" |
| `max` | "Maximum value is X" |
| `email` | "Invalid email address" |
| `pattern` | "Invalid format" |
| Custom | Uses `error.message` or "Validation error: key" |

### Custom Error Messages

For custom error messages, provide a `message` property in your validator's error object:

<Source
  language="typescript"
  code={`
// Custom validator with descriptive message
function customValidator(control: AbstractControl): ValidationErrors | null {
  if (!isValid(control.value)) {
    return {
      customError: {
        message: 'Please enter a valid XYZ format'
      }
    };
  }
  return null;
}
`}
/>

## CSS Classes

Angular Forms automatically adds validation classes to the grid element:

| Class | Description |
|-------|-------------|
| `.ng-valid` / `.ng-invalid` | Validation state |
| `.ng-pristine` / `.ng-dirty` | Edit state |
| `.ng-untouched` / `.ng-touched` | Touch state |
| `.form-disabled` | Added when control is disabled |

```css
tbw-grid.ng-invalid.ng-touched {
  border: 2px solid red;
}

tbw-grid.form-disabled {
  opacity: 0.6;
  pointer-events: none;
}
```

## Cell-Level Invalid Styling

When Angular validation fails, the grid visually highlights invalid cells using CSS custom properties:

```css
tbw-grid {
  /* Customize invalid cell appearance */
  --tbw-invalid-bg: #fef2f2;
  --tbw-invalid-border-color: #ef4444;
}
```

This integrates seamlessly with the EditingPlugin's validation system, meaning Angular's `Validators.required`, `Validators.email`, etc. automatically show visual feedback in the grid.
